# 4.6 Приведение типов указателей. Константа NULL

* **Подвиг 1.** Выберите все верные варианты объявления указателей.
  * (-)int* u, v, c; // u, v, c - указатели
  * (+)float *a, *b, *c; // a, b, c - указатели
  * (+)double* a;
  * (-)unsigned * short ptr_hd;
  * (+)long * ptr_var;
  * (-)unsigned * char ptr_byte;
 
* **Подвиг 2.** Выберите все верные варианты, касающиеся указателей.
  * (+)указатель с типом void* можно присваивать указателям любых других типов без возникновения каких-либо предупреждений со стороны компилятора
  * (+)присваивание адресов указателей разных типов приводит к предупреждению при компиляции программы
  * (+)указатели разных типов могут ссылаться на одну и ту же область памяти
  * (+)присвоение указателей разных типов следует выполнять с операцией приведения типа одного указателя к другому
  * (+)константа NULL языка Си служит для обозначения неиницализированного указателя (на выделенную область памяти)
  * (-)указатели разных типов не могут ссылаться на одну и ту же область памяти
 
* **Подвиг 6.** Выберите все верные утверждения, касающиеся приведенной программы.
```C
int main(void)
{
    char ch = 'a';
    char* ptr = &ch;

    int * ptr_i = (int *)ptr;
    *ptr_i = 0;

    return 0;
}
```
* Select all correct options from the list
  * (+)команда *ptr_i = 0; последовательно запишет четыре 0, начиная с ячейки памяти с адресом ptr_i
  * (+)указатели ptr и ptr_i содержат один и тот же адрес
  * (-)команда *ptr_i = 0; запишет один 0, в ячейку памяти с адресом ptr_i
  * (+)программа имеет потенциальную уязвимость, так как указатель ptr_i работает с 4 байтами (обычно), а ptr ссылается на выделенную область в один байт
  * (-)в строчке int * ptr_i = (int *)ptr; не хватает амперсанда (&) перед именем указателя ptr
  * (-)указатели ptr и ptr_i ссылаются на одну и ту же область памяти

* **Подвиг 8 (на повторение).** Выберите все верные утверждения, касающиеся тернарной условной операции.
  * (-)данная операция определяется синтаксисом: ? (<выражение 1>) <выражение 2> : <выражение 3>
  * (+)приоритет тернарной условной операции ниже операций сравнения и арифметических операций
  * (+)данная операция работает по принципу if-else (если-иначе) и возвращает либо одно, либо другое вычисленное выражение
  * (-)данная операция не может быть использована совместно с другими вычислениями
  * (+)данная операция именно операция и может быть использована совместно с другими вычислениями
  * (+)данная операция определяется синтаксисом: <выражение 1> ? <выражение 2> : <выражение 3>
  * (-)приоритет тернарной условной операции выше операций сравнения, но ниже арифметических операций

* **Подвиг 9 (на повторение).** Выберите все верные утверждения, касающиеся условного оператора if/else.
  * (+)переход на else осуществляется только при ложном условии
  * (+)оператор if можно записать по синтаксису: if(<выражение>) <оператор>;
  * (-)оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> равно нулю
  * (-)переход на else осуществляется только при истинном условии
  * (+)условные операторы также называют операторами ветвления
  * (-)по некоторому условию можно выполнить строго только один оператор
  * (+)по некоторому условию можно выполнить сразу несколько операторов, записав их в фигурных скобках
  * (+)оператор if можно записать по синтаксису: if(<выражение>) <оператор 1>; else <оператор 2>;
  * (+)оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> не равно нулю
